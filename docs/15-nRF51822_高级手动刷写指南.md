# nRF51822 高级手动刷写指南

本文档专为**高级玩家**设计。如果你希望完全掌控编译、Patch 和刷写的每一个细节，或者希望将其集成到自己的 CI/CD 流程中，请参考本指南。

这里不依赖任何自动化脚本，所有操作均在终端中手动执行。

---

## 1. 环境准备

确保你已经安装了以下工具路径环境：

- `arm-none-eabi-gcc` (编译工具链)
- `nrfjprog` (J-Link 刷写工具)
- `openocd` (ST-Link 刷写工具)
- `python3` (密钥生成)
- `openssl`, `xxd`, `grep`, `dd` (Patch 工具)

---

## 2. 密钥准备

### 场景 A: Static Mode (静态密钥)

如果使用固定密钥，你需要先生成密钥对。

```bash
# 生成 1 个密钥，前缀为 ADV001，输出到 keys_out 目录
python3 heystack-nrf5x/tools/generate_keys.py -n 1 -p ADV001 -o keys_out/
```

生成的 `keys_out/ADV001_keyfile` 是我们需要的二进制密钥文件。

### 场景 B: Dynamic Mode (动态密钥)

如果使用动态密钥，你需要生成一个 32 字节的随机 Seed。

```bash
# 生成 hex 格式 seed
openssl rand -hex 32 > seed_ADV001.hex

# 转换为二进制格式 (Patch 需要二进制)
xxd -r -p seed_ADV001.hex seed_ADV001.bin
```

---

## 3. 固件编译

进入源码目录进行编译。你可以通过 `make` 参数完全控制固件行为。

**常用参数:**

- `DYNAMIC_KEYS=1`: 启用动态密钥模式 (不加则为静态模式)
- `ADVERTISING_INTERVAL=2000`: 广播间隔 (毫秒)
- `HAS_DCDC=1`: 启用 DCDC (省电，但需要硬件支持)
- `HAS_BATTERY=1`: 启用电池电量报告

```bash
# 进入工程目录
cd heystack-nrf5x/nrf51822/armgcc

# 清理旧构建
make clean

# 编译 (示例：动态模式，3000ms 间隔，启用 DCDC)
make nrf51822_xxab DYNAMIC_KEYS=1 ADVERTISING_INTERVAL=3000 HAS_DCDC=1

# 编译成功后，产物位于 _build/nrf51822_xxab.hex
```

---

## 4. 固件 Patch (核心步骤)

原始固件中只包含占位符，我们需要将密钥或 Seed 注入进去。

**准备工作:**

```bash
# 回到项目根目录
cd ../../../

# 定义构建路径
BUILD_DIR="heystack-nrf5x/nrf51822/armgcc/_build"

# 1. 将 HEX 转为 BIN (方便计算偏移量)
arm-none-eabi-objcopy -I ihex -O binary "$BUILD_DIR/nrf51822_xxab.hex" "$BUILD_DIR/nrf51822_xxab.bin"
cp "$BUILD_DIR/nrf51822_xxab.bin" "$BUILD_DIR/firmware_patched.bin"
```

### 方式 A: Patch 动态 Seed

```bash
# 1. 查找占位符偏移量 (LinkyTagDynamicSeedPlaceholder!!)
OFFSET=$(grep -oba "LinkyTagDynamicSeedPlaceholder!!" "$BUILD_DIR/nrf51822_xxab.bin" | cut -d ':' -f 1)
echo "Offset found at: $OFFSET"

# 2. 写入 Seed (使用 dd 命令)
# 假设你的 seed 文件是 seed_ADV001.bin
dd if=seed_ADV001.bin of="$BUILD_DIR/firmware_patched.bin" bs=1 seek=$OFFSET count=32 conv=notrunc
```

### 方式 B: Patch 静态 Keyfile

```bash
# 1. 查找占位符偏移量 (OFFLINEFINDINGPUBLICKEYHERE!)
OFFSET=$(grep -oba "OFFLINEFINDINGPUBLICKEYHERE!" "$BUILD_DIR/nrf51822_xxab.bin" | cut -d ':' -f 1)
echo "Offset found at: $OFFSET"

# 2. 写入 Keyfile
# 注意：keyfile 第一个字节是数量，我们需要跳过它 (skip=1)
# 假设你的 keyfile 是 keys_out/ADV001_keyfile
dd if=keys_out/ADV001_keyfile of="$BUILD_DIR/firmware_patched.bin" bs=1 skip=1 seek=$OFFSET conv=notrunc
```

### 转换回 HEX

为了安全刷写 (正确处理地址偏移)，建议转回 Hex 格式。
nRF51822 的 Application起始地址通常是 `0x1B000` (如果带 SoftDevice S130)。

```bash
arm-none-eabi-objcopy -I binary -O ihex --change-addresses 0x1B000 "$BUILD_DIR/firmware_patched.bin" "$BUILD_DIR/firmware_patched.hex"
```

---

## 5. 手动刷写

### SoftDevice (协议栈)

如果你是第一次刷写，或者擦除了全片，必须先刷入 SoftDevice。

**路径**: `nrf-sdk/nRF5_SDK_12.3.0_d7731ad/components/softdevice/s130/hex/s130_nrf51_2.0.1_softdevice.hex`

### 选项 1: 使用 J-Link (nrfjprog)

```bash
# 1. 擦除扇区并刷入 SoftDevice
nrfjprog -f nrf51 --program nrf-sdk/nRF5_SDK_12.3.0_d7731ad/components/softdevice/s130/hex/s130_nrf51_2.0.1_softdevice.hex --sectorerase

# 2. 刷入 Patch 后的固件
nrfjprog -f nrf51 --program "$BUILD_DIR/firmware_patched.hex" --sectorerase --verify

# 3. 复位运行
nrfjprog -f nrf51 --reset
```

### 选项 2: 使用 ST-Link (OpenOCD)

ST-Link 需要通过 OpenOCD 桥接。你可以编写一个临时的 `.cfg` 文件或直接在命令行传参。

```bash
# 定义 SoftDevice 路径
SD_PATH="nrf-sdk/nRF5_SDK_12.3.0_d7731ad/components/softdevice/s130/hex/s130_nrf51_2.0.1_softdevice.hex"

# 执行刷写命令
# init; halt; -> 初始化
# nrf51 mass_erase; -> 批量擦除 (如果是新片或锁住的片)
# program $SD_PATH verify; -> 刷入协议栈
# program .../firmware_patched.hex verify; -> 刷入应用
# reset; exit -> 复位退出

openocd -f interface/stlink.cfg -f target/nrf51.cfg -c "init; halt; nrf51 mass_erase; program $SD_PATH verify; program $BUILD_DIR/firmware_patched.hex verify; reset; exit"
```

---

## 6. (可选) 离线生成追踪数据

如果你使用了 **Dynamic Mode**，你可能想生成用来追踪的 JSON 文件。

```bash
# 使用 python 脚本根据 seed 生成 json
# -s: Seed 的 Hex 字符串
# -n: 生成数量
# -p: 设备前缀名
SEED_HEX=$(cat seed_ADV001.hex)

python3 heystack-nrf5x/tools/generate_keys_from_seed.py -s "$SEED_HEX" -n 200 -p ADV001 -o my_configs/
```

执行后，`my_configs/ADV001_devices.json` 即为追踪文件。

---

## 7. (极客模式) 纯 Makefile 一行流

如果你不想手动拆解那么多步骤，或者你想回归最原始的极客方式，我们的 **Makefile 已经高度封装**。你可以直接通过传递参数，**只用一条命令** 就完成 编译+Patch+刷写。

此方法直接利用 `Makefile.common` 中定义的逻辑，适合熟练掌握 `make` 的玩家。

### 这个命令做了什么？

它会自动执行：

1. `compile`: 编译源码。
2. `patch`: 调用 Python 或 Shell 脚本，把 `ADV_KEYS_FILE` 注入到固件。
3. `flash`: 调用 OpenOCD 或 nrfjprog 刷入。

### 7.1 ST-Link 一行流刷写 (Static Mode)

```bash
# 进入目录
cd heystack-nrf5x/nrf51822/armgcc

# 执行一键命令
make stflash-nrf51822_xxab-patched \
    HAS_DCDC=0 \
    HAS_BATTERY=1 \
    KEY_ROTATION_INTERVAL=900 \
    MAX_KEYS=200 \
    ADVERTISING_INTERVAL=2040 \
    ADV_KEYS_FILE=../../../config/TCC004_keyfile
```

**参数详解**:

- `stflash-nrf51822_xxab-patched`: 目标名称。
  - `stflash`: 使用 ST-Link (OpenOCD).
  - `patched`: 表示需要 Patch keyfile。
- `ADV_KEYS_FILE=...`: 指定 Keyfile 的**相对路径** (注意是在 `armgcc` 目录下运行，所以要 `../../../`).

### 7.2 J-Link 一行流刷写 (Static Mode)

只需将目标改为 `flash-nrf51822_xxab-patched` (默认 `flash` 是 J-Link)。

```bash
make flash-nrf51822_xxab-patched \
    HAS_DCDC=0 \
    HAS_BATTERY=1 \
    ADVERTISING_INTERVAL=3000 \
    ADV_KEYS_FILE=../../../config/MSF001_keyfile
```

### 7.3 Dynamic Mode 一行流

对于 Dynamic Mode，我们通常不需要指定 `ADV_KEYS_FILE` (因为是 Seed)，目前 Makefile 主要设计用于 Static Keyfile Patching。
但在 Dynamic Mode 下，你依然可以使用 `make` 来编译并刷入 **无 Payload** 的版本 (然后自己手动 Patch Seed，或者修改 Makefile 支持 Seed Patch)。

```bash
# 仅编译+刷写 (无 Patch)
make stflash-nrf51822_xxab \
    DYNAMIC_KEYS=1 \
    ADVERTISING_INTERVAL=2000
```

*注意：如果不 Patch Seed，Dynamic 固件将使用默认的硬编码 Seed (LinkyTagDynamicSeedPlaceholder!!)，所有设备 ID 都会相同。*

---

## 8. 高级 CLI 脚本工具 (半自动)

为了平衡“手动敲命令的繁琐”和“统一工具的交互式”，我们还提供了两个**非交互式**的命令行脚本。它们非常适合集成到批量处理脚本或 CI/CD 中。

### 8.1 密钥/Seed 生成器 (`advanced_keygen.sh`)

一键生成 Static Keyfile 或 Dynamic Seed（含离线追踪 JSON）。

**用法**:

```bash
./advanced_keygen.sh -m <static|dynamic> -p <PREFIX> [-n COUNT]
```

**示例**:

```bash
# [Static] 生成 50 个密钥文件，前缀 TCC
./advanced_keygen.sh -m static -p TCC -n 50

# [Dynamic] 为 MSF001 生成 Seed，并预计算 200 个离线追踪 Key
./advanced_keygen.sh -m dynamic -p MSF001 -n 200
```

### 8.2 编译刷写工具 (`advanced_flash.sh`)

一键完成 "Clean -> Compile -> Patch -> Flash" 流程，无需人工干预。

**用法**:

```bash
./advanced_flash.sh -n <DEVICE_NAME> -m <static|dynamic> -d <jlink|stlink> [-i INTERVAL]
```

**示例**:

```bash
# 刷写一台名为 MSF001 的设备 (需要先生成 Seed)
./advanced_flash.sh -n MSF001 -m dynamic -d jlink -i 3000

# 刷写一台名为 TCC005 的设备 (需要先生成 Keyfile)
./advanced_flash.sh -n TCC005 -m static -d stlink
```

# nRF52810 芯片保护修复与刷机实战指南

## 📋 概述
本文档记录了完整的芯片保护修复和固件刷写流程，基于实际操作经验总结，适用于遇到芯片保护问题的用户。

## 🚨 问题识别

### 芯片保护的表现
当芯片处于保护状态时，会出现以下现象：
- OpenOCD连接失败或提示访问受限
- 编程操作失败
- 无法正常读取芯片内容
- 出现"Programming failed"错误

### 检测命令
```bash
# 检测芯片连接状态
cd heystack-nrf5x/nrf52810/armgcc
openocd -f openocd.cfg -c "init; targets; exit"
```

**正常输出示例**：
```
Info : Target voltage: 3.204156
Info : [nrf52.cpu] Cortex-M4 r0p1 processor detected
Info : [nrf52.cpu] target has 6 breakpoints, 4 watchpoints
```

**保护状态提示**：
```
nRF52 device has a CTRL-AP dedicated to recover the device from AP lock.
A high level adapter (like a ST-Link) you are currently using cannot access
the CTRL-AP so 'nrf52_recover' command will not work.
```

## 🛠️ 芯片保护修复流程

### 方法1: ST-Link + OpenOCD mass_erase (推荐)

#### 步骤1: 检测连接
```bash
cd /path/to/nRF52810-AirTag-Toolkit/heystack-nrf5x/nrf52810/armgcc
openocd -f openocd.cfg -c "init; targets; exit"
```

#### 步骤2: 执行mass_erase
```bash
openocd -f openocd.cfg -c "init; halt; nrf5 mass_erase; reset; exit"
```

**成功标志**：
```
Info : Mass erase completed.
```

#### 步骤3: 验证恢复
```bash
openocd -f openocd.cfg -c "init; targets; exit"
```

### 方法2: nrfjprog恢复 (需要J-Link)

#### 前提条件
```bash
# 检查nrfjprog是否可用
nrfjprog --version

# 如果未安装
brew install --cask nordic-nrf-command-line-tools
```

#### 执行恢复
```bash
# nRF52系列
nrfjprog --recover -f nrf52

# nRF51系列
nrfjprog --recover -f nrf51
```

#### 验证恢复
```bash
nrfjprog --readcode -f nrf52
```

### 方法3: 使用恢复脚本 (自动化)

#### 快速恢复
```bash
# 自动检测并恢复
./scripts/quick_chip_recovery.sh

# 指定芯片类型
./scripts/quick_chip_recovery.sh nrf51
```

#### 完整恢复
```bash
# 查看所有选项
./scripts/recover_protected_chip.sh -h

# 指定参数恢复
./scripts/recover_protected_chip.sh -t nrf52810 -d stlink
```

## 🔥 固件刷写流程

### 准备工作

#### 1. 检查环境
```bash
# 运行环境检查
./scripts/one_click_verify.sh

# 或手动检查关键工具
which arm-none-eabi-gcc
which openocd
which mergehex
```

#### 2. 确认SDK安装
```bash
# 检查SDK目录
ls -la nrf-sdk/nRF5_SDK_15.3.0_59ac345/

# 如果不存在，需要下载并解压SDK
```

### 密钥文件处理 (关键步骤)

#### 问题：密钥补丁验证失败
**错误信息**：
```
The key was not patched correctly!
```

**原因**：密钥文件缺少结束标记

#### 解决方案：添加结束标记

##### 方法1: 手动修复单个密钥文件
```bash
# 进入项目根目录
cd /path/to/nRF52810-AirTag-Toolkit

# 复制密钥文件到编译目录
cp config/DEVICE_keyfile heystack-nrf5x/nrf52810/armgcc/

# 添加结束标记
cd heystack-nrf5x/nrf52810/armgcc
echo -n -e '\x2d\x6e\x20\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x21\x0a' >> DEVICE_keyfile
```

##### 方法2: 安全的修复方法
```bash
# 创建临时文件避免覆盖
cp config/DEVICE_keyfile /tmp/DEVICE_fixed.keyfile
echo -n -e '\x2d\x6e\x20\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x21\x0a' >> /tmp/DEVICE_fixed.keyfile

# 复制到编译目录
cp /tmp/DEVICE_fixed.keyfile heystack-nrf5x/nrf52810/armgcc/DEVICE_keyfile
```

#### 验证修复结果
```bash
# 检查文件大小 (应该增加32字节)
ls -la DEVICE_keyfile

# 检查文件结尾
xxd -s -40 DEVICE_keyfile
```

**正确的结尾应该显示**：
```
....: ....-n ENDOFKEYSENDOFKEYSENDOFKEYS!.
```

### 编译和刷写

#### 方法1: 使用make命令
```bash
cd heystack-nrf5x/nrf52810/armgcc

# 编译和刷写
make stflash-nrf52810_xxaa-patched \
    HAS_DCDC=0 \
    HAS_BATTERY=1 \
    KEY_ROTATION_INTERVAL=300 \
    MAX_KEYS=200 \
    ADVERTISING_INTERVAL=2000 \
    ADV_KEYS_FILE=./DEVICE_keyfile
```

#### 方法2: 使用便捷脚本
```bash
# 修改脚本中的设备名
sed 's/R0VVSW/DEVICE_NAME/g' scripts/compile_and_flash_2s.sh > /tmp/compile_and_flash_DEVICE.sh
chmod +x /tmp/compile_and_flash_DEVICE.sh

# 运行脚本
/tmp/compile_and_flash_DEVICE.sh
```

### 成功标志

#### 编译成功
```
DONE nrf52810_xxaa
merging application and softdevice... : nrf52810_xxaa
Patching nrf52810_xxaa
✅ 没有出现 "The key was not patched correctly!" 错误
```

#### 刷写成功
```
Info : Mass erase completed.
** Programming Finished **
** Verified OK **
```

## 📝 完整实战案例

### 案例1: R0VVSW密钥刷写
```bash
# 1. 芯片保护修复
cd heystack-nrf5x/nrf52810/armgcc
openocd -f openocd.cfg -c "init; halt; nrf5 mass_erase; reset; exit"

# 2. 密钥文件修复
cp ../../../config/R0VVSW_keyfile .
echo -n -e '\x2d\x6e\x20\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x21\x0a' >> R0VVSW_keyfile

# 3. 编译刷写
make stflash-nrf52810_xxaa-patched \
    HAS_DCDC=0 HAS_BATTERY=1 KEY_ROTATION_INTERVAL=300 \
    MAX_KEYS=200 ADVERTISING_INTERVAL=2000 ADV_KEYS_FILE=./R0VVSW_keyfile
```

### 案例2: LUO001密钥刷写
```bash
# 1. 使用脚本自动恢复芯片保护
./scripts/quick_chip_recovery.sh

# 2. 准备LUO001密钥
cp config/LUO001_keyfile /tmp/LUO001_fixed.keyfile
echo -n -e '\x2d\x6e\x20\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x21\x0a' >> /tmp/LUO001_fixed.keyfile
cp /tmp/LUO001_fixed.keyfile heystack-nrf5x/nrf52810/armgcc/LUO001_keyfile

# 3. 使用便捷脚本刷写
sed 's/R0VVSW/LUO001/g' scripts/compile_and_flash_2s.sh > /tmp/compile_and_flash_luo001.sh
chmod +x /tmp/compile_and_flash_luo001.sh
/tmp/compile_and_flash_luo001.sh
```

### 案例3: 4P0EP4密钥刷写
```bash
# 1. 芯片保护已修复的情况下直接刷写
cd /path/to/nRF52810-AirTag-Toolkit

# 2. 安全修复密钥文件
cp config/4P0EP4_keyfile /tmp/4P0EP4_fixed.keyfile
echo -n -e '\x2d\x6e\x20\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x21\x0a' >> /tmp/4P0EP4_fixed.keyfile
cp /tmp/4P0EP4_fixed.keyfile heystack-nrf5x/nrf52810/armgcc/4P0EP4_keyfile

# 3. 编译刷写
cd heystack-nrf5x/nrf52810/armgcc
make stflash-nrf52810_xxaa-patched \
    HAS_DCDC=0 HAS_BATTERY=1 KEY_ROTATION_INTERVAL=300 \
    MAX_KEYS=200 ADVERTISING_INTERVAL=2000 ADV_KEYS_FILE=./4P0EP4_keyfile
```

## 🔧 故障排除

### 常见问题1: SDK未找到
**错误**：
```
❌ 错误: nRF5 SDK 未找到，请先下载并解压到 nrf-sdk/ 目录
```

**解决**：
1. 下载nRF5_SDK_15.3.0_59ac345.zip
2. 解压到项目根目录的nrf-sdk/文件夹

### 常见问题2: 工具链未找到
**错误**：
```
arm-none-eabi-gcc: Command not found
```

**解决**：
```bash
# 安装工具链
brew install --cask gcc-arm-embedded

# 检查安装
which arm-none-eabi-gcc
```

### 常见问题3: 密钥补丁失败
**错误**：
```
The key was not patched correctly!
```

**解决**：按照本文档的密钥文件处理流程添加结束标记

### 常见问题4: 连接失败
**错误**：
```
unable to connect to the target
```

**解决**：
1. 检查硬件连接
2. 确认ST-Link驱动正常
3. 尝试芯片保护修复流程

## 📊 参数配置说明

### 编译参数详解
| 参数 | 值 | 说明 | 推荐设置 |
|------|----|----- |----------|
| `HAS_DCDC` | 0/1 | 稳压器类型 | 0 (LDO, 更兼容) |
| `HAS_BATTERY` | 0/1 | 电量报告 | 1 (启用) |
| `KEY_ROTATION_INTERVAL` | 秒 | 密钥轮换间隔 | 300 (5分钟) |
| `MAX_KEYS` | 个数 | 最大密钥数量 | 200 |
| `ADVERTISING_INTERVAL` | 毫秒 | 广播间隔 | 2000 (2秒) |

### 广播间隔建议
| 间隔 | 频率 | 电池寿命 | 响应速度 | 适用场景 |
|------|------|----------|----------|----------|
| 1000ms | 1次/秒 | 中等 | 快 | 测试开发 |
| 2000ms | 1次/2秒 | 好 | 中等 | 日常使用 |
| 5000ms | 1次/5秒 | 很好 | 慢 | 长期部署 |

## 🚀 快速操作模板

### 新设备刷写模板
```bash
#!/bin/bash
# 新设备刷写模板

DEVICE_NAME="YOUR_DEVICE_NAME"
PROJECT_PATH="/path/to/nRF52810-AirTag-Toolkit"

cd $PROJECT_PATH

# 1. 芯片保护修复
./scripts/quick_chip_recovery.sh

# 2. 密钥文件修复
cp config/${DEVICE_NAME}_keyfile /tmp/${DEVICE_NAME}_fixed.keyfile
echo -n -e '\x2d\x6e\x20\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x45\x4e\x44\x4f\x46\x4b\x45\x59\x53\x21\x0a' >> /tmp/${DEVICE_NAME}_fixed.keyfile
cp /tmp/${DEVICE_NAME}_fixed.keyfile heystack-nrf5x/nrf52810/armgcc/${DEVICE_NAME}_keyfile

# 3. 编译刷写
cd heystack-nrf5x/nrf52810/armgcc
make stflash-nrf52810_xxaa-patched \
    HAS_DCDC=0 \
    HAS_BATTERY=1 \
    KEY_ROTATION_INTERVAL=300 \
    MAX_KEYS=200 \
    ADVERTISING_INTERVAL=2000 \
    ADV_KEYS_FILE=./${DEVICE_NAME}_keyfile

echo "✅ ${DEVICE_NAME} 设备刷写完成！"
```

## 📋 检查清单

### 刷写前检查
- [ ] 硬件连接正确 (3.3V, GND, SWDIO, SWCLK)
- [ ] ST-Link驱动正常
- [ ] 开发环境完整 (SDK, 工具链)
- [ ] 密钥文件存在

### 刷写后验证
- [ ] 看到 "Programming Finished"
- [ ] 看到 "Verified OK"
- [ ] 没有 "The key was not patched correctly!" 错误
- [ ] 设备能正常启动

## 💡 最佳实践

### 1. 密钥文件管理
- 始终备份原始密钥文件
- 使用临时文件进行修复操作
- 验证文件大小和结尾标记

### 2. 故障排除策略
- 优先使用自动化脚本
- 逐步排查：连接→环境→密钥→编译
- 保留详细的操作日志

### 3. 开发效率
- 创建设备专用脚本
- 使用模板快速配置新设备
- 定期验证开发环境

## 📞 获取帮助

### 相关文档
- [芯片保护恢复指南](10-芯片保护恢复指南.md) - 理论和工具说明
- [硬件连接与刷写指南](04-硬件连接与刷写.md) - 硬件连接详情
- [快速参考手册](05-快速参考手册.md) - 常用命令速查

### 脚本工具
- `./scripts/quick_chip_recovery.sh` - 快速芯片恢复
- `./scripts/recover_protected_chip.sh` - 完整恢复选项
- `./scripts/one_click_verify.sh` - 环境验证

---
*基于实际操作经验编写*  
*最后更新: 2024年7月26日*  
*适用版本: nRF52810-AirTag-Toolkit v1.0*